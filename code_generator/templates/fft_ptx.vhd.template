library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

{% set component_name='fft_pt'~point %}
{% set lhs_component_name='fft_pt'~lhs_point %}
{% set rhs_component_name='fft_pt'~rhs_point %}

entity {{ component_name }} is
    GENERIC (
        ctrl_start     : INTEGER := 0
    );
    PORT (
        tmp_first_stage_re_out, tmp_first_stage_im_out: out std_logic_vector({{ point-1 }} downto 0);
        tmp_mul_re_out, tmp_mul_im_out : out std_logic_vector({{ point-1 }} downto 0);

        clk            : IN STD_LOGIC;
        rst            : IN STD_LOGIC;
        ce             : IN STD_LOGIC;
        {% if istop %}
        ctrl           : IN STD_LOGIC;
        {% else %}
        ctrl_delay     : IN STD_LOGIC_VECTOR(15 downto 0);
        {% endif %}

        data_re_in:in std_logic_vector({{ point-1 }} downto 0);
        data_im_in:in std_logic_vector({{ point-1 }} downto 0);

        data_re_out:out std_logic_vector({{ point-1 }} downto 0);
        data_im_out:out std_logic_vector({{ point-1 }} downto 0)
    );
end {{ component_name }};

architecture Behavioral of {{ component_name }} is

component {{ lhs_component_name }} is
    GENERIC (
        ctrl_start       : INTEGER
    );
    PORT (
        clk            : IN STD_LOGIC;
        rst            : IN STD_LOGIC;
        ce             : IN STD_LOGIC;
        ctrl_delay     : IN STD_LOGIC_VECTOR(15 downto 0);

        data_re_in:in std_logic_vector({{ lhs_point-1 }} downto 0);
        data_im_in:in std_logic_vector({{ lhs_point-1 }} downto 0);

        data_re_out:out std_logic_vector({{ lhs_point-1 }} downto 0);
        data_im_out:out std_logic_vector({{ lhs_point-1 }} downto 0)
    );
end component;

{% if lhs_point!=rhs_point %}
component {{ rhs_component_name }} is
    GENERIC (
        ctrl_start       : INTEGER
    );
    PORT (
        clk            : IN STD_LOGIC;
        rst            : IN STD_LOGIC;
        ce             : IN STD_LOGIC;
        ctrl_delay     : IN STD_LOGIC_VECTOR(15 downto 0);

        data_re_in     : in std_logic_vector({{ rhs_point-1 }} downto 0);
        data_im_in     : in std_logic_vector({{ rhs_point-1 }} downto 0);

        data_re_out     : out std_logic_vector({{ rhs_point-1 }} downto 0);
        data_im_out     : out std_logic_vector({{ rhs_point-1 }} downto 0)
    );
end component;
{% endif %}

component complex_multiplier is
    GENERIC (
        re_multiplicator : INTEGER;
        im_multiplicator : INTEGER;
        ctrl_start       : INTEGER
    );
    PORT (
        clk             : IN std_logic;
        rst             : IN std_logic;
        ce              : IN std_logic;
        ctrl_delay      : IN STD_LOGIC_VECTOR(15 downto 0);
        data_re_in      : IN std_logic;
        data_im_in      : IN std_logic;
        product_re_out  : OUT STD_LOGIC;
        product_im_out  : OUT STD_LOGIC
    );
end component;

component Dff_regN is
    GENERIC( N: INTEGER );
    Port (
            D : in  STD_LOGIC;
            clk : in  STD_LOGIC;
            Q : out  STD_LOGIC
        );
end component;

component shifter is
    port(
            clk            : IN STD_LOGIC;
            rst            : IN STD_LOGIC;
            ce             : IN STD_LOGIC;
            ctrl           : IN STD_LOGIC;
            data_in:in std_logic;
            data_out:out std_logic
        );
end component;

COMPONENT Dff_preload_reg1_init_1 IS
    PORT (
        D        : IN STD_LOGIC;
        clk      : IN STD_LOGIC;
        preload  : IN STD_LOGIC;
        Q        : OUT STD_LOGIC;
        QN       : OUT STD_LOGIC
    );
END COMPONENT;

component adder_half_bit1
    PORT (
        data1_in  : IN STD_LOGIC;
        data2_in  : IN STD_LOGIC;
        sum_out   : OUT STD_LOGIC;
        c_out     : OUT STD_LOGIC
    );
end component;

signal first_stage_re_out, first_stage_im_out: std_logic_vector({{ point-1 }} downto 0);
signal mul_re_out, mul_im_out : std_logic_vector({{ point-1 }} downto 0);
signal shifter_re,shifter_im:std_logic_vector({{point-1}} downto 0);
signal not_first_stage_re_out: std_logic_vector({{point-1}} downto 0);
signal opp_first_stage_re_out: std_logic_vector({{point-1}} downto 0);
signal c: std_logic_vector({{point-1}} downto 0);
signal c_buff: std_logic_vector({{point-1}} downto 0);

{% if istop %}
SIGNAL ctrl_delay : std_logic_vector(15 downto 0);
{% endif %}

begin
    {% if istop %}
    --- create ctrl_delay signal in top module
    ctrl_delay(0) <= ctrl;
    --- buffer for ctrl
    PROCESS (clk, rst, ce, ctrl)
    BEGIN
        IF clk'EVENT AND clk = '1' THEN
            IF rst = '0' THEN
                ctrl_delay(15 DOWNTO 1) <= (OTHERS => '0');
            ELSIF ce = '1' THEN
                ctrl_delay(15 DOWNTO 1) <= ctrl_delay(14 DOWNTO 0);
            END IF;
        END IF;
    END PROCESS;
    {% endif %}

    tmp_first_stage_re_out <= first_stage_re_out;
    tmp_first_stage_im_out <= first_stage_im_out;
    tmp_mul_re_out <= mul_re_out;
    tmp_mul_im_out <= mul_im_out;

    --- left-hand-side processors
    {% for i in range(rhs_point) %}
    UL{{lhs_component_name|upper}}_{{i}} : {{ lhs_component_name }}
    generic map(
        ctrl_start => ctrl_start
    )
    port map(
            clk=>clk,
            rst=>rst,
            ce=>ce,
            ctrl_delay=>ctrl_delay,
            {% for j in range(0,lhs_point) %}
            data_re_in({{j}})=>data_re_in({{i+j*rhs_point}}),
            {% endfor %}
            {% for j in range(0,lhs_point) %}
            data_im_in({{j}})=>data_im_in({{i+j*rhs_point}}),
            {% endfor %}
            data_re_out=>first_stage_re_out({{lhs_point*(i+1)-1}} downto {{lhs_point*i}}),
            data_im_out=>first_stage_im_out({{lhs_point*(i+1)-1}} downto {{lhs_point*i}})
        );

    {% endfor %}

    --- right-hand-side processors
    {% for i in range(lhs_point) %}
    UR{{rhs_component_name|upper}}_{{i}} : {{ rhs_component_name }}
    generic map(
        ctrl_start => (ctrl_start+{{delay}}) mod 16
    )
    port map(
            clk=>clk,
            rst=>rst,
            ce=>ce,
            ctrl_delay=>ctrl_delay,
            {% for j in range(rhs_point) %}
            data_re_in({{j}})=>mul_re_out({{index[i][j]}}),
            {% endfor %}
            {% for j in range(rhs_point) %}
            data_im_in({{j}})=>mul_im_out({{index[i][j]}}),
            {% endfor %}
            {% for j in range(rhs_point) %}
            data_re_out({{j}})=>data_re_out({{i+j*lhs_point}}),
            {% endfor %}
            {% for j in range(rhs_point) %}
            data_im_out({{j}})=>data_im_out({{i+j*lhs_point}}){{',' if not loop.last}}
            {% endfor %}
        );           

    {% endfor %}

    --- multipliers
    {% for i in range(point) %}
    {% if w[i]==(2**14,0) %} {#- TODO: judge if w[i] is identity other than 1, e.g. j, -1, -j #}
    USHIFTER_{{i}}_RE: shifter
    port map(
            clk=>clk,
            rst=>rst,
            ce=>ce,
            ctrl=>ctrl_delay((ctrl_start+{{delay}}) mod 16),
            data_in=>first_stage_re_out({{i}}),
            data_out=>shifter_re({{i}})
        );
    USHIFTER_{{i}}_IM: shifter
    port map(
            clk=>clk,
            rst=>rst,
            ce=>ce,
            ctrl=>ctrl_delay((ctrl_start+{{delay}}) mod 16),
            data_in=>first_stage_im_out({{i}}),
            data_out=>shifter_im({{i}})
        );
    UDELAY_{{i}}_RE : Dff_regN
    generic map(N=>15)
    port map(
            D=>shifter_re({{i}}),
            clk=>clk,
            Q=>mul_re_out({{i}})
        );
    UDELAY_{{i}}_IM : Dff_regN
    generic map(N=>15)
    port map(
            D=>shifter_im({{i}}),
            clk=>clk,
            Q=>mul_im_out({{i}})
        );

    {% elif w[i]==(0,-(2**14)) %}
    not_first_stage_re_out({{i}}) <= not first_stage_re_out({{i}});
    C_BUFF_{{i}} : Dff_preload_reg1_init_1
    PORT MAP(
        D        => c({{i}}), 
        clk      => clk, 
        preload  => ctrl_delay((ctrl_start+{{delay}}) mod 16), 
        Q        => c_buff({{i}})
    );
    ADDER_{{i}} : adder_half_bit1
    PORT MAP(
        data1_in  => c_buff({{i}}), 
        data2_in  => not_first_stage_re_out({{i}}), 
        sum_out   => opp_first_stage_re_out({{i}}), 
        c_out     => c({{i}})
    );
    USHIFTER_{{i}}_RE: shifter
    port map(
            clk=>clk,
            rst=>rst,
            ce=>ce,
            ctrl=>ctrl_delay((ctrl_start+{{delay}}) mod 16),
            data_in=>first_stage_im_out({{i}}),
            data_out=>shifter_re({{i}})
        );
    USHIFTER_{{i}}_IM: shifter
    port map(
            clk=>clk,
            rst=>rst,
            ce=>ce,
            ctrl=>ctrl_delay((ctrl_start+{{delay}}) mod 16),
            data_in=>opp_first_stage_re_out({{i}}),
            data_out=>shifter_im({{i}})
        );
    UDELAY_{{i}}_RE : Dff_regN
    generic map(N=>15)
    port map(
            D=>shifter_re({{i}}),
            clk=>clk,
            Q=>mul_re_out({{i}})
        );
    UDELAY_{{i}}_IM : Dff_regN
    generic map(N=>15)
    port map(
            D=>shifter_im({{i}}),
            clk=>clk,
            Q=>mul_im_out({{i}})
        );

    {% else %}
    UMUL_{{i}} : complex_multiplier
    generic map(
            re_multiplicator=>{{w[i][0]}}, --- {{w[i][0]/2.0**14}} + j{{w[i][1]/2.0**14}}
            im_multiplicator=>{{w[i][1]}},
            ctrl_start => (ctrl_start+{{delay}}) mod 16
        )
    port map(
            clk=>clk,
            rst=>rst,
            ce=>ce,
            ctrl_delay=>ctrl_delay,
            data_re_in=>first_stage_re_out({{i}}),
            data_im_in=>first_stage_im_out({{i}}),
            product_re_out=>mul_re_out({{i}}),
            product_im_out=>mul_im_out({{i}})
        );

    {% endif %}
    {% endfor %}
end Behavioral;

